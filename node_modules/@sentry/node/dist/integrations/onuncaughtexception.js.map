{"version":3,"file":"onuncaughtexception.js","sourceRoot":"","sources":["../../src/integrations/onuncaughtexception.ts"],"names":[],"mappings":";;;AAAA,qCAAoD;AACpD,uCAAsD;AACtD,+CAA8C;AAC9C,wCAAkD;AAElD,uCAAuC;AACvC;IAiBE;;OAEG;IACH,6BACmB,OAEX;QAFW,wBAAA,EAAA,YAEX;QAFW,YAAO,GAAP,OAAO,CAElB;QAtBR;;WAEG;QACI,SAAI,GAAW,mBAAmB,CAAC,EAAE,CAAC;QAM7C;;WAEG;QACa,YAAO,GAA2B,gBAAgB;QAChE,2BAA2B;QAC3B,IAAI,CAAC,OAAO,CAAC,YAAY,CAC1B,CAAC;IAQC,CAAC;IACJ;;OAEG;IACI,uCAAS,GAAhB;QACE,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,mBAAmB,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAClE,CAAC;IAzBD;;OAEG;IACW,sBAAE,GAAW,qBAAqB,CAAC;IAuBnD,0BAAC;CAAA,AA/BD,IA+BC;AA/BY,kDAAmB;AAiChC,YAAY;AACZ,SAAgB,gBAAgB,CAC9B,YAAoF;IADtF,iBAiEC;IAhEC,6BAAA,EAAA,eAAiE,8BAAmB;IAEpF,IAAM,OAAO,GAAG,IAAI,CAAC;IACrB,IAAI,gBAAgB,GAAY,KAAK,CAAC;IACtC,IAAI,iBAAiB,GAAY,KAAK,CAAC;IACvC,IAAI,gBAAgB,GAAY,KAAK,CAAC;IACtC,IAAI,UAAiB,CAAC;IAEtB,OAAO,UAAC,KAAY;QAClB,IAAI,CAAC,gBAAgB,EAAE;YACrB,IAAM,KAAG,GAAG,oBAAa,EAAE,CAAC;YAE5B,6EAA6E;YAC7E,0EAA0E;YAC1E,6FAA6F;YAC7F,UAAU,GAAG,KAAK,CAAC;YACnB,gBAAgB,GAAG,IAAI,CAAC;YAExB,IAAI,KAAG,CAAC,cAAc,CAAC,mBAAmB,CAAC,EAAE;gBAC3C,KAAG,CAAC,SAAS,CAAC,UAAO,KAAY;;wBAC/B,KAAK,CAAC,QAAQ,CAAC,gBAAQ,CAAC,KAAK,CAAC,CAAC;wBAC/B,KAAG,CAAC,gBAAgB,CAAC,KAAK,EAAE,EAAE,iBAAiB,EAAE,KAAK,EAAE,CAAC,CAAC;wBAC1D,IAAI,CAAC,gBAAgB,EAAE;4BACrB,gBAAgB,GAAG,IAAI,CAAC;4BACxB,YAAY,CAAC,KAAK,CAAC,CAAC;yBACrB;;;qBACF,CAAC,CAAC;aACJ;iBAAM;gBACL,IAAI,CAAC,gBAAgB,EAAE;oBACrB,gBAAgB,GAAG,IAAI,CAAC;oBACxB,YAAY,CAAC,KAAK,CAAC,CAAC;iBACrB;aACF;SACF;aAAM,IAAI,gBAAgB,EAAE;YAC3B,+FAA+F;YAC/F,eAAM,CAAC,IAAI,CAAC,gGAAgG,CAAC,CAAC;YAC9G,8BAAmB,CAAC,KAAK,CAAC,CAAC;SAC5B;aAAM,IAAI,CAAC,iBAAiB,EAAE;YAC7B,4CAA4C;YAC5C,kFAAkF;YAClF,sDAAsD;YACtD,mFAAmF;YACnF,qFAAqF;YACrF,sGAAsG;YACtG,2EAA2E;YAC3E,+EAA+E;YAC/E,oFAAoF;YACpF,mCAAmC;YACnC,6IAA6I;YAC7I,6MAA6M;YAC7M,iHAAiH;YACjH,wGAAwG;YACxG,iBAAiB,GAAG,IAAI,CAAC;YACzB,UAAU,CAAC;gBACT,IAAI,CAAC,gBAAgB,EAAE;oBACrB,+EAA+E;oBAC/E,gBAAgB,GAAG,IAAI,CAAC;oBACxB,YAAY,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;iBACjC;qBAAM;oBACL,+FAA+F;iBAChG;YACH,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,sIAAsI;SACpJ;IACH,CAAC,CAAC;AACJ,CAAC;AAjED,4CAiEC","sourcesContent":["import { getCurrentHub, Scope } from '@sentry/core';\nimport { Integration, Severity } from '@sentry/types';\nimport { logger } from '@sentry/utils/logger';\nimport { defaultOnFatalError } from '../handlers';\n\n/** Global Promise Rejection handler */\nexport class OnUncaughtException implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public name: string = OnUncaughtException.id;\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'OnUncaughtException';\n\n  /**\n   * @inheritDoc\n   */\n  public readonly handler: (error: Error) => void = makeErrorHandler(\n    // tslint:disable-next-line\n    this.options.onFatalError,\n  );\n  /**\n   * @inheritDoc\n   */\n  public constructor(\n    private readonly options: {\n      onFatalError?(firstError: Error, secondError?: Error): void;\n    } = {},\n  ) {}\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    global.process.on('uncaughtException', this.handler.bind(this));\n  }\n}\n\n/** JSDoc */\nexport function makeErrorHandler(\n  onFatalError: (firstError: Error, secondError?: Error) => void = defaultOnFatalError,\n): (error: Error) => void {\n  const timeout = 2000;\n  let caughtFirstError: boolean = false;\n  let caughtSecondError: boolean = false;\n  let calledFatalError: boolean = false;\n  let firstError: Error;\n\n  return (error: Error): void => {\n    if (!caughtFirstError) {\n      const hub = getCurrentHub();\n\n      // this is the first uncaught error and the ultimate reason for shutting down\n      // we want to do absolutely everything possible to ensure it gets captured\n      // also we want to make sure we don't go recursion crazy if more errors happen after this one\n      firstError = error;\n      caughtFirstError = true;\n\n      if (hub.getIntegration(OnUncaughtException)) {\n        hub.withScope(async (scope: Scope) => {\n          scope.setLevel(Severity.Fatal);\n          hub.captureException(error, { originalException: error });\n          if (!calledFatalError) {\n            calledFatalError = true;\n            onFatalError(error);\n          }\n        });\n      } else {\n        if (!calledFatalError) {\n          calledFatalError = true;\n          onFatalError(error);\n        }\n      }\n    } else if (calledFatalError) {\n      // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down\n      logger.warn('uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown');\n      defaultOnFatalError(error);\n    } else if (!caughtSecondError) {\n      // two cases for how we can hit this branch:\n      //   - capturing of first error blew up and we just caught the exception from that\n      //     - quit trying to capture, proceed with shutdown\n      //   - a second independent error happened while waiting for first error to capture\n      //     - want to avoid causing premature shutdown before first error capture finishes\n      // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff\n      // so let's instead just delay a bit before we proceed with our action here\n      // in case 1, we just wait a bit unnecessarily but ultimately do the same thing\n      // in case 2, the delay hopefully made us wait long enough for the capture to finish\n      // two potential nonideal outcomes:\n      //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError\n      //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error\n      // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)\n      //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish\n      caughtSecondError = true;\n      setTimeout(() => {\n        if (!calledFatalError) {\n          // it was probably case 1, let's treat err as the sendErr and call onFatalError\n          calledFatalError = true;\n          onFatalError(firstError, error);\n        } else {\n          // it was probably case 2, our first error finished capturing while we waited, cool, do nothing\n        }\n      }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc\n    }\n  };\n}\n"]}