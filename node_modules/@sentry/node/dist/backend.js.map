{"version":3,"file":"backend.js","sourceRoot":"","sources":["../src/backend.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseBackend, Dsn, getCurrentHub, Options, SentryError } from '@sentry/core';\nimport { SentryEvent, SentryEventHint, SentryResponse, Severity } from '@sentry/types';\nimport { isError, isPlainObject } from '@sentry/utils/is';\nimport { limitObjectDepthToSize, serializeKeysToEventMessage } from '@sentry/utils/object';\nimport { createHash } from 'crypto';\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\nimport { HTTPSTransport, HTTPTransport } from './transports';\n\n/**\n * Configuration options for the Sentry Node SDK.\n * @see NodeClient for more information.\n */\nexport interface NodeOptions extends Options {\n  [key: string]: any;\n\n  /** Callback that is executed when a fatal global error occurs. */\n  onFatalError?(error: Error): void;\n\n  /** Sets an optional server name (device name) */\n  serverName?: string;\n\n  /** Maximum time to wait to drain the request queue, before the process is allowed to exit. */\n  shutdownTimeout?: number;\n\n  /** Set a HTTP proxy that should be used for outbound requests. */\n  httpProxy?: string;\n\n  /** Set a HTTPS proxy that should be used for outbound requests. */\n  httpsProxy?: string;\n\n  /** HTTPS proxy certificates path */\n  caCerts?: string;\n}\n\n/** The Sentry Node SDK Backend. */\nexport class NodeBackend extends BaseBackend<NodeOptions> {\n  /**\n   * @inheritDoc\n   */\n  public async eventFromException(exception: any, hint?: SentryEventHint): Promise<SentryEvent> {\n    let ex: any = exception;\n\n    if (!isError(exception)) {\n      if (isPlainObject(exception)) {\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        const keys = Object.keys(exception as {}).sort();\n        const message = `Non-Error exception captured with keys: ${serializeKeysToEventMessage(keys)}`;\n\n        getCurrentHub().configureScope(scope => {\n          scope.setExtra('__serialized__', limitObjectDepthToSize(exception as {}));\n          scope.setFingerprint([\n            createHash('md5')\n              .update(keys.join(''))\n              .digest('hex'),\n          ]);\n        });\n\n        ex = (hint && hint.syntheticException) || new Error(message);\n        (ex as Error).message = message;\n      } else {\n        // This handles when someone does: `throw \"something awesome\";`\n        // We use synthesized Error here so we can extract a (rough) stack trace.\n        ex = (hint && hint.syntheticException) || new Error(exception as string);\n      }\n    }\n\n    const event: SentryEvent = await parseError(ex as Error);\n\n    return {\n      ...event,\n      event_id: hint && hint.event_id,\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async eventFromMessage(\n    message: string,\n    level: Severity = Severity.Info,\n    hint?: SentryEventHint,\n  ): Promise<SentryEvent> {\n    const event: SentryEvent = {\n      event_id: hint && hint.event_id,\n      level,\n      message,\n    };\n\n    if (this.options.attachStacktrace && hint && hint.syntheticException) {\n      const stack = hint.syntheticException ? await extractStackFromError(hint.syntheticException) : [];\n      const frames = await parseStack(stack);\n      event.stacktrace = {\n        frames: prepareFramesForEvent(frames),\n      };\n    }\n\n    return event;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async sendEvent(event: SentryEvent): Promise<SentryResponse> {\n    let dsn: Dsn;\n\n    if (!this.options.dsn) {\n      throw new SentryError('Cannot sendEvent without a valid DSN');\n    } else {\n      dsn = new Dsn(this.options.dsn);\n    }\n\n    if (!this.transport) {\n      const transportOptions = this.options.transportOptions ? this.options.transportOptions : { dsn };\n      const clientOptions = ['httpProxy', 'httpsProxy', 'caCerts'];\n\n      for (const option of clientOptions) {\n        if (this.options[option]) {\n          transportOptions[option] = transportOptions[option] || this.options[option];\n        }\n      }\n\n      this.transport = this.options.transport\n        ? new this.options.transport({ dsn })\n        : dsn.protocol === 'http'\n        ? new HTTPTransport(transportOptions)\n        : new HTTPSTransport(transportOptions);\n    }\n\n    return this.transport.captureEvent(event);\n  }\n}\n"]}