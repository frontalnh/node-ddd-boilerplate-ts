{"version":3,"file":"async.js","sourceRoot":"","sources":["src/async.ts"],"names":[],"mappings":";;;AAAA;;;GAGG;AACH,SAAgB,MAAM,CAAC,OAAqB;IAC1C,OAAO,CAAC,KAAK,CAAC,UAAA,CAAC;QACb,uCAAuC;QACvC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACnB,CAAC,CAAC,CAAC;AACL,CAAC;AALD,wBAKC;AAED;;;;;;;GAOG;AACH,SAAsB,WAAW,CAC/B,KAAU,EACV,SAAkD,EAClD,OAAa;;;;;wBAEI,qBAAM,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC,EAAA;;oBAA3D,QAAQ,GAAG,SAAgD;oBACjE,sBAAO,KAAK,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,KAAK,IAAK,OAAA,QAAQ,CAAC,KAAK,CAAC,EAAf,CAAe,CAAC,EAAC;;;;CACpD;AAPD,kCAOC","sourcesContent":["/**\n * Consumes the promise and logs the error when it rejects.\n * @param promise A promise to forget.\n */\nexport function forget(promise: Promise<any>): void {\n  promise.catch(e => {\n    // TODO: Use a better logging mechanism\n    console.error(e);\n  });\n}\n\n/**\n * Helper to filter an array with asynchronous callbacks.\n *\n * @param array An array containing items to filter.\n * @param predicate An async predicate evaluated on every item.\n * @param thisArg Optional value passed as \"this\" into the callback.\n * @returns An array containing only values where the callback returned true.\n */\nexport async function filterAsync<T>(\n  array: T[],\n  predicate: (item: T) => Promise<boolean> | boolean,\n  thisArg?: any,\n): Promise<T[]> {\n  const verdicts = await Promise.all(array.map(predicate, thisArg));\n  return array.filter((_, index) => verdicts[index]);\n}\n"]}