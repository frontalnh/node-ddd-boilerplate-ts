"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const schema_generator_1 = require("../schema/schema-generator");
const loadResolversFromGlob_1 = require("../helpers/loadResolversFromGlob");
const emitSchemaDefinitionFile_1 = require("./emitSchemaDefinitionFile");
function buildSchema(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        loadResolvers(options);
        const schema = yield schema_generator_1.SchemaGenerator.generateFromMetadata(options);
        if (options.emitSchemaFile) {
            const schemaFileName = getSchemaDefinitionFileName(options);
            yield emitSchemaDefinitionFile_1.emitSchemaDefinitionFile(schemaFileName, schema);
        }
        return schema;
    });
}
exports.buildSchema = buildSchema;
function buildSchemaSync(options) {
    loadResolvers(options);
    const schema = schema_generator_1.SchemaGenerator.generateFromMetadataSync(options);
    if (options.emitSchemaFile) {
        const schemaFileName = getSchemaDefinitionFileName(options);
        emitSchemaDefinitionFile_1.emitSchemaDefinitionFileSync(schemaFileName, schema);
    }
    return schema;
}
exports.buildSchemaSync = buildSchemaSync;
function loadResolvers(options) {
    if (options.resolvers.length === 0) {
        throw new Error("Empty `resolvers` array property found in `buildSchema` options!");
    }
    options.resolvers.forEach(resolver => {
        if (typeof resolver === "string") {
            loadResolversFromGlob_1.loadResolversFromGlob(resolver);
        }
    });
}
function getSchemaDefinitionFileName(options) {
    return typeof options.emitSchemaFile === "string"
        ? options.emitSchemaFile
        : emitSchemaDefinitionFile_1.defaultSchemaFilePath;
}
