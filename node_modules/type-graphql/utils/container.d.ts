import { ResolverData } from "../interfaces";
export declare type SupportedType<T> = {
    new (...args: any[]): T;
} | Function;
export interface ContainerType {
    get(someClass: any, resolverData: ResolverData<any>): any;
}
export declare type ContainerGetter<TContext extends object> = (resolverData: ResolverData<TContext>) => ContainerType;
/**
 * Container options.
 */
export interface UseContainerOptions {
    /**
     * If set to true, then default container will be used in the case
     * if given container haven't returned anything.
     */
    fallback?: boolean;
    /**
     * If set to true, then default container will be used in the case
     * if given container thrown an exception.
     */
    fallbackOnErrors?: boolean;
}
export declare abstract class IOCContainer {
    private static userContainer?;
    private static userContainerGetter?;
    private static userContainerOptions;
    private static defaultContainer;
    /**
     * Sets the container to the basic, default one.
     * Used mainly for testing purposes.
     */
    static restoreDefault(): void;
    /**
     * Sets container to be used by this library.
     */
    static useContainer(iocContainer: ContainerType, options?: UseContainerOptions): void;
    /**
     * Sets container getter function to be used by this library.
     */
    static useContainerGetter(containerGetter: ContainerGetter<any>, options?: UseContainerOptions): void;
    /**
     * Gets the class instance from IOC container used by this library.
     */
    static getInstance<T = any>(someClass: SupportedType<T>, resolverData: ResolverData<any>): T;
}
export declare function useContainer(iocContainer: ContainerType, options?: UseContainerOptions): void;
export declare function useContainer<TContext extends object>(containerGetter: ContainerGetter<TContext>, options?: UseContainerOptions): void;
//# sourceMappingURL=container.d.ts.map